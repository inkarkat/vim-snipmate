snippet vim7
	- Requires Vim 7.0 or higher.
snippet vim8
	- Requires Vim 8.0 or higher.
snippet au
	- ${1:`expand('%:t:r')`}.vim autoload script${2}
snippet pl
	- ${1:`expand('%:t:r')`}.vim plugin${2}
snippet plo
	- ${1:`expand('%:t:r')`}.vim plugin (optional${2})${3}
snippet ingopl
	- ingo-library.vim plugin
snippet header
	" File: ${1:`expand('%:t')`}
	" Author: ${2:`g:snips_author`}
	" Description: ${3}
	${4:" Last Modified: `strftime("%B %d, %Y")`}
snippet guard
	" Avoid installing twice or when in unsupported Vim version.
	if exists('g:loaded_${1:`Filename('', 'plugin')`}') || (v:version < ${2:700})
		finish
	endif
	let g:loaded_$1 = 1

snippet cpo-save
	let s:save_cpo = &cpo
	set cpo&vim
snippet cpo-restore
	${1}let &cpo = s:save_cpo
	unlet s:save_cpo
snippet temp-option default
	let l:save_${1:setting} = &$1
	set $1=${3:}${2:tempval}
	try
		${4}
	finally
		let &$1 = l:save_$1
	endtry
snippet temp-option local
	let l:save_${1:setting} = &l:$1
	setlocal $1=${3:}${2:tempval}
	try
		${4}
	finally
		let &l:$1 = l:save_$1
	endtry
snippet footer
	" vim: set ts=8 sts=4 sw=4 noexpandtab ff=unix fdm=syntax :
snippet fun
	function! ${1:`(ingo#fs#path#split#Contains(expand('%:p'), '/autoload/') ? substitute(matchstr(ingo#fs#path#Normalize(expand('%:p:h'), '/') . '/', '.*/autoload/\zs.*'), '/', '#', 'g') : '') . expand('%:t:r') . '#'`}(${2})
		${3}
	endfunction${4}
snippet for
	for ${1:needle} in ${2:haystack}
		${3:" code}
	endfor
snippet wh
	while ${1:condition}
		${2:" code}
	endwhile
snippet if
	if ${1:condition}
		${2:" code}
	endif
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	endif
snippet contains
	index(${1:list}, ${2:value}) != -1${3}
snippet catch all Vim exceptions with ingo#err library
	catch /^Vim\%((\a\+)\)\=:/
		call ingo#err#SetVimException()
	${1}
snippet catch all Vim exceptions with ingo#msg library
	catch /^Vim\%((\a\+)\)\=:/
		call ingo#msg#VimExceptionMsg()
	${1}
snippet catch all Vim exceptions
	catch /^Vim\%((\a\+)\)\=:/
snippet catch all Vim exceptions inline in a mapping
	catch /^Vim\%((\a\+)\)\=:/<Bar>echoerr substitute(v:exception, '^Vim\%((\a\+)\)\=:', '', '')<Bar>endtry${1}
snippet catch all Vim exceptions and accumulate
	let l:errors = []
	${1}
	catch /^Vim\%((\a\+)\)\=:/
	    call add(l:errors, ingo#msg#MsgFromVimException())
	${2}
	if ! empty(l:errors)
		call ingo#err#Set(join(l:errors))
		return 0
	endif
	return 1${3}
snippet catch one particular Vim exception
	catch /^Vim\%((\a\+)\)\=:E${1:123}:/${2: " E$1: }${3:}
		call ingo#msg#VimExceptionMsg()${4}
snippet catch custom exceptions with ingo#err library
	catch /^${1:`expand('%:t:r')`}:${2:}/
		call ingo#err#SetCustomException('$1')${2}
snippet catch custom exceptions with ingo#msg library
	catch /^${1:`expand('%:t:r')`}:${2:}/
		call ingo#msg#CustomExceptionMsg('$1')${2}
snippet catch custom exceptions
	catch /^${1:`expand('%:t:r')`}:${2:}/
		${3}
snippet catch rethrow
	catch /^Vim\%((\a\+)\)\=:/
		throw ingo#msg#MsgFromVimException()   " Avoid E608: Cannot :throw exceptions with 'Vim' prefix.
snippet catch everything except Vim exceptions with ingo#msg library
	catch /^Vim\%((\a\+)\)\=:E/
		throw ingo#msg#MsgFromVimException()   " Don't swallow Vimscript errors.
	catch /^Vim\%((\a\+)\)\=:/
		call ingo#msg#VimExceptionMsg()        " Errors from :echoerr.
	catch
		call ingo#msg#ErrorMsg(v:exception)    " Anything else.
snippet catch everything except Vim exceptions with ingo#err library
	catch /^Vim\%((\a\+)\)\=:E/
		throw ingo#msg#MsgFromVimException()   " Don't swallow Vimscript errors.
	catch /^Vim\%((\a\+)\)\=:/
		call ingo#err#SetVimException()        " Errors from :echoerr.
		return 0
	catch
		call ingo#err#Set(v:exception)         " Anything else.
		return 0
snippet catch everything and echoerr it in a mapping
	catch<Bar>echoerr ingo#msg#MsgFromVimException()${1}
snippet catch everything except (Vim) Interrupt and echoerr it in a mapping
	catch<Bar>if v:exception !~# '^\%(Vim:\)\?Interrupt$'<Bar>echoerr ingo#msg#MsgFromVimException()<Bar>endif<Bar>endtry${1}
snippet assert
	throw 'ASSERT: ${1:false}'${2}
snippet assert-unknown
	throw 'ASSERT: Unknown ${1:var}: ' . string(${2:l:}$1)${3}
snippet assert-invalid
	throw 'ASSERT: Invalid ${1:var}: ' . string(${2:l:}$1)${3}
snippet ingoerr command
	| echoerr ingo#err#Get() | endif
snippet ingoerr command with explicit check
	| if ingo#err#IsSet() | echoerr ingo#err#Get() | endif
snippet ingoerr mapping
	<Bar>echoerr ingo#err#Get()<Bar>endif
snippet ingoerr command with context
	| echoerr ingo#err#Get(${1:`string(expand('%:t:r'))`}) | endif${2}
snippet ingoerr command with explicit check and context
	| if ingo#err#IsSet(${1:`string(expand('%:t:r'))`}) | echoerr ingo#err#Get($1) | endif${2}
snippet ingoerr mapping with context
	<Bar>echoerr ingo#err#Get(${1:`string(expand('%:t:r'))`})<Bar>endif${2}
snippet errmsg
	let v:errmsg = '${1:Error}'
	echohl ErrorMsg
	echomsg v:errmsg
	echohl None
snippet warningmsg
	let v:warningmsg = ${1:'Warning'}
	echohl WarningMsg
	echomsg v:warningmsg
	echohl None
snippet redir
	redir => ${1:l:variable}Output
		silent! ${2:command}
	redir END
	redraw	" This is necessary because of the :redir done earlier.
	let $1 = ${3}split($1Output, "\n")
snippet record-position
	function! s:RecordPosition()
		" The position record consists of the current cursor position, the buffer
		" number and its current change state. When this position record is assigned
		" to a window-local variable, it is also linked to the current window and
		" tab page.
		return getpos('.') + [bufnr(''), b:changedtick]
	endfunction

snippet moved-au
	Moved functions from plugin to separate autoload script.
snippet sid-get
	let l:SID = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_')

snippet sid-function
	function! s:function(name)
		return function(substitute(a:name, '^s:', matchstr(expand('<sfile>'), '<SNR>\d\+_\zefunction$'),''))
	endfunction

snippet sid-cache
	function! s:DetermineSid()
		let s:SID = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_DetermineSid$')
	endfunction
	call s:DetermineSid()
	delfunction s:DetermineSid

snippet sid-function-cached
	function! s:function(name)
		return function(substitute(a:name, '^s:', s:SID,''))
	endfunction
snippet abc-list
	split('abcdefghijklmnopqrstuvwxyz', '\zs')
snippet regexp-unescaped
	\\%(\\%(^\\|[^\\\\]\\)\\%(\\\\\\\\\\)*\\\\\\)\\@<!${1: }
snippet regexp-escaped
	\\%(\\%(^\\|[^\\\\]\\)\\%(\\\\\\\\\\)*\\\\\\)\\@<!\\\\${1:x}
snippet regexp-quoted one type of quote
	${1:"}\\%(\\%(\\%(^\\|[^\\\\]\\)\\%(\\\\\\\\\\)*\\\\\\)\\@<!\\\\$1\\|[^$1]\\)*$1${2}
snippet regexp-quoted multiple types of quote
	\\([${1:'"}]\\)\\%(\\%(\\%(^\\|[^\\\\]\\)\\%(\\\\\\\\\\)*\\\\\\)\\@<!\\\\\\1\\|\\%(\\1\\@!.\\)\\)*\\1${2}
snippet regexp-ascii 7bit
	[\x00-\x7F]
snippet regexp-ascii 8bit
	[\x00-\xFF]
snippet regexp-number integer
	[+-]\\?\\d\\+
snippet regexp-number hexadecimal
	\\%(0x\\)\\?\\x\\+
snippet regexp-number float
	[+-]\\?\\d\\+\\.\\d\\+\\%([eE][+-]\\?\\d\\+\\)\\?
snippet regexp-number integer or float
	[+-]\\?\\d\\+\\%(\\.\\d\\+\\%([eE][+-]\\?\\d\\+\\)\\?\\)\\?
snippet regexp-number hexadecimal or integer or float
	\\%(0x\\)\\?\\x\\+\\|[+-]\\?\\d\\+\\%(\\.\\d\\+\\%([eE][+-]\\?\\d\\+\\)\\?\\)\\?
snippet indenttest
	catch /bla/	${1:one tab}after it
		lalaal	${2:more}	and more
		hehehe
			huhu ${3:name}	gaga
				hzhz	${4:and?}		gaga
			hoho $3
	endcatch
snippet ftplugin-inherit
	" Inherit all settings from the "${1:unknown}" filetype.
	runtime! ftplugin/$1.vim ftplugin/$1_*.vim ftplugin/$1/*.vim
snippet ftplugin-undo
	let b:undo_ftplugin = (exists('b:undo_ftplugin') ? b:undo_ftplugin . '|' : '') . 'setlocal ${1:setting}<${2}'${3}
snippet beep command
	execute "normal! \<C-\>\<C-n>\<Esc>" | " Beep.
snippet beep mapping
	<Bar>execute "normal! \<lt>C-\>\<lt>C-n>\<lt>Esc>"
snippet configvar
	if ! exists('g:`expand('%:t:r')`_${1:ConfigItem}')
		let g:`expand('%:t:r')`_$1 = ${2:'default value'}
	endif${3}
snippet plugmap
	${1:n}noremap <silent> <Plug>(${2:`expand('%:t:r')`}${3:}) :<C-u>call ${4:`expand('%:t:r')`#}${5:$2()}<CR>
	if ! hasmapto('<Plug>($2$3)', '$1')
		$1map ${6:DefaultMapping} <Plug>($2$3)
	endif${7}
snippet plugmaptt
	call TextTransform#MakeMappings('${1:}', '', '${2:algorithm}')
	if ! hasmapto('<Plug>TextT$2${3:[Line|Operator|Visual]}', '${4:n}')
		$4map ${5:DefaultMapping} <Plug>TextT$2$3
	endif${7}
snippet no-maps
	! exists('g:no_${1:`expand('%:t:r')`}_maps')${2}
snippet hasmapto
	if ! hasmapto('<Plug>(${1:`expand('%:t:r')`}${2:})', '${3:n}')
		$3map ${4:DefaultMapping} <Plug>($1$2)
	endif${5}
snippet haswin
	has('dos16') || has('dos32') || has('win95') || has('win32') || has('win64')
snippet hascygwin
	has('win32unix')
snippet ErrorMsg
	function! s:ErrorMsg( text )
		let v:errmsg = a:text
		echohl ErrorMsg
		echomsg v:errmsg
		echohl None
	endfunction
snippet WarningMsg
	function! s:WarningMsg( text )
		let v:warningmsg = a:text
		echohl WarningMsg
		echomsg v:warningmsg
		echohl None
	endfunction
snippet ExceptionMsg
	function! s:ExceptionMsg( exception )
		" v:exception contains what is normally in v:errmsg, but with extra
		" exception source info prepended, which we cut away.
		call s:ErrorMsg(substitute(a:exception, '^Vim\%((\a\+)\)\=:', '', ''))
	endfunction
snippet option-contains
	index(split(&${1:option}, ','), ${2:expr}) ${3:=}= -1${4}
snippet path-separator
	(exists('+shellslash') && ! &shellslash ? '\' : '/')
snippet optional-init
	(a:0 ? a:1 : {})
snippet optional-args
	let l:options = (a:0 ? a:1 : {})
snippet optional-test
	has_key(${1:l}:options, '${2:optionname}')${3}
snippet optional-access
	get(${1:l}:options, '${2:optionname}', ${3:''})${4}
snippet optional-arg
	let l:${1:optionname} = get(${2:l}:options, '${3:$1}', ${4:''})${5}
snippet undo-search-effects direct
	call histdel('search', -1) | let @/ = histget('search', -1) | nohlsearch
snippet undo-search-effects ingocommands
	UndoSearchEffects
snippet undo-search-effects at the end of a function
	call histdel('search', -1)
snippet noop mapping
	call setline('.', getline('.'))${1:<Bar>}${2}
snippet noop mapping that may fail
	if !&ma<Bar><Bar>&ro<Bar>call setline('.', getline('.'))<Bar>endif${1:<Bar>}${2}
snippet noop command
	call setline(${1:<line1>}, getline($1))${2: | }${3}
snippet opmode-onemore
	" The difference between normal mode, operator-pending and visual
	" mode with 'selection' set to "exclusive" is that in the latter
	" two, the motion must go _past_ the final "word" character, so that
	" all characters of the "word" are selected. This is done by
	" appending a 'l' motion after the search for the next "word".
	"
	" The 'l' motion only works properly at the end of the line (i.e.
	" when the moved-over "word" is at the end of the line) when the 'l'
	" motion is allowed to move over to the next line. Thus, the 'l'
	" motion is added temporarily to the global 'whichwrap' setting.
	" Without this, the motion would leave out the last character in the
	" line.
	let l:save_ww = &whichwrap
	set whichwrap+=l
	if a:mode ==# 'O' && line('.') == line('$') && &virtualedit !=# 'onemore' && &virtualedit !=# 'all'
		" For the last line in the buffer, that still doesn't work,
		" unless we can do virtual editing.
		let l:save_ve = &virtualedit
		set virtualedit=onemore
		normal! l
		augroup TempVirtualEdit
			execute 'autocmd! CursorMoved * set virtualedit=' . l:save_ve . ' | autocmd! TempVirtualEdit'
		augroup END
	else
		normal! l
	endif
	let &whichwrap = l:save_ww
snippet max-int
	0x7FFFFFFF
snippet repeat call
	silent! call repeat#set("\<Plug>${1:(`expand('%:t:r')`)}"${2:, l:count})${3}
snippet repeat call together with visualrepeat
	silent! call       repeat#set("\<Plug>${1:(`expand('%:t:r')`)}"${2:, l:count})
	silent! call visualrepeat#set("\<Plug>$1"$2)${3}
snippet repeat call in mapping (with :execute)
	execute 'silent! call repeat#set("\<lt>Plug>${1:(`expand('%:t:r')`)}"${2:, v:count})'${3}
snippet repeat call in mapping, last
	silent! call repeat#set("\<lt>Plug>${1:(`expand('%:t:r')`)}"${2:, v:count})${3}
snippet repeat call in mapping together with visualrepeat
	execute 'silent! call repeat#set("\<lt>Plug>${1:(`expand('%:t:r')`)}"${2:, v:count})'<Bar>execute 'silent! call visualrepeat#set("\<lt>Plug>$1"$2')${3}
snippet repeat dependency
	- repeat.vim (vimscript #2136) autoload script (optional)
	- visualrepeat.vim (vimscript #3848) autoload script (optional)
snippet funcref-loading
	if v:version < 702 | runtime autoload/${1:`expand('%:t:r')`}${2}.vim | endif  " The Funcref doesn't trigger the autoload in older Vim versions.${3}
snippet read-range
	(<line2> == 1 ? <line1> : <line2>)
snippet patch exact version
	v:version == ${1:`v:version`} && has('patch${2:000}')${3}
snippet patch above version
	v:version == ${1:`v:version`} && has('patch${2:000}') || v:version > $1${3}
snippet patch below version
	v:version < $1 || v:version == ${1:`v:version`} && ! has('patch${2:000}')${3}
snippet patch in between same version
	v:version == ${1:`v:version`} && has('patch${2:000}') && ! has('patch${3:999}')${4}
snippet patch in between adjacent versions
	v:version == ${1:`v:version - 1`} && has('patch${2:000}') || v:version == ${3:`v:version`} && ! has('patch${4:999}')${5}
snippet patch in between different versions
	v:version == ${1:`v:version - 2`} && has('patch${2:000}') || v:version > $1 && v:version < $3 || v:version == ${3:`v:version`} && ! has('patch${4:999}')${5}
snippet d
	echomsg '****${1:text}'${2}
snippet ds
	echomsg '****${3}' string(${1:expr})${2}${4}
snippet s
	string(${1:expr})${2}
snippet ss
	'${1:expr}='.string($1)${2}
snippet plural
	(${1:`matchstr(getline('.'), '\%([bglstw]:\)\?\k\+\ze\%(\k\@!.\)\+$')`} == 1 ? '' : 's')${2}
snippet save-view
	let l:save_view = winsaveview()
	${1}
	call winrestview(l:save_view)
snippet save-layout
	let l:originalWindowLayout = winrestcmd()
		let l:originalWinNr = winnr()
		let l:previousWinNr = winnr('#') ? winnr('#') : 1
			${1:windo}
		execute l:previousWinNr . 'wincmd w'
		execute l:originalWinNr . 'wincmd w'
	silent! execute l:originalWindowLayout
snippet save-cursor
	let l:save_cursor = ingo#compat#getcurpos()
	${1}
	call setpos('.', l:save_cursor)
snippet save-visualarea
	let l:save_visualarea = [visualmode(), getpos("'<"), getpos("'>")]
	${1}
	if visualmode() !=# l:save_visualarea[0] && ! empty(l:save_visualarea[0])
		execute 'normal!' l:save_visualarea[0] . "\<Esc>"
	endif
	call ingo#compat#setpos("'<", l:save_visualarea[1])
	call ingo#compat#setpos("'>", l:save_visualarea[2])
snippet save-cwd
	if ! empty(${1:dirspec}) && ! ingo#fs#path#Equals($1, getcwd())
		let l:save_cwd = getcwd()
		let l:chdirCommand = (haslocaldir() ? 'lchdir!' : 'chdir!')
		execute l:chdirCommand ingo#compat#fnameescape($1)
	endif
	try
		${2}
	finally
		if exists('l:save_cwd')
			execute l:chdirCommand ingo#compat#fnameescape(l:save_cwd)
		endif
	endtry
snippet save-change
	let [l:save_change_begin, l:save_change_end] = [getpos("'["), getpos("']")]
		${2}
	call setpos("'[", l:save_change_begin)
	call setpos("']", l:save_change_end)
snippet set-change
	call setpos("'[", ${1:[0, l:startLnum, 1, 0]})
	call setpos("']", ${2:[0, l:endLnum, 1, 0]})${3}
snippet complete-args
	ArgLead, CmdLine, CursorPos
snippet sel
	&selection ==# 'exclusive'
snippet doautocmd
	if v:version == 703 && has('patch438') || v:version > 703
		silent doautocmd <nomodeline> User ${1:`expand('%:t:r')`}
	else
		silent doautocmd              User $1
	endif${2}
snippet drop
	((exists(':Drop') == 2) ? 'Drop' : 'drop')
snippet force-autoload
	silent! call ${1:modulename}#DoesNotExist()	" Execute a function to force autoload.${2}
snippet fnameshorten
	fnamemodify(${1:l:filespec}, ':~:.')${2}
snippet scriptDir
	expand('<sfile>:p:h')
snippet NetStartEnd
	let [l:startLnum, l:endLnum] = [ingo#range#NetStart(a:startLnum), ingo#range#NetEnd(a:endLnum)]
snippet deletedLineNum
	let l:lineNum = line('$')
	${1:execute printf('%d,%dCommand', l:startLnum, l:endLnum)}
	let l:deletedLineNum = l:lineNum - line('$')
	let l:endLnum -= l:deletedLineNum${2}
snippet addedLineNum
	let l:lineNum = line('$')
	${1:execute printf('%d,%dCommand', l:startLnum, l:endLnum)}
	let l:addedLineNum = line('$') - l:lineNum
	let l:endLnum += l:addedLineNum${2}
snippet shell_error
	if v:shell_error != 0
		call ingo#err#Set('${1:command} failed: shell returned ' . v:shell_error . (empty(${2:l:result}) ? '' : ': ' . $2))
		return
	endif${3}
