# #!/bin/bash
snippet #!
	#!/bin/${1:ba}sh
	${2}
snippet #!source
	#!/bin/${1:ba}sh source-this-script
	${2}
snippet @@
	"${${1:array}[@]}"${2}
snippet @empty
	[ ${#${1:array}[@]} -eq 0 ]${2}
snippet @nonempty
	[ ${#${1:array}[@]} -gt 0 ]${2}
snippet rev
	`getline('.') =~# '^\s*#\s*$' ? (getline('.') =~# '#\s\+$' ? '' : ' ') : '# '`Version: "@(#) $Revision$"
snippet if
	if [ ${1:condition} ]; then
		${2:#statements}
	fi
snippet elif
	elif [ ${1:condition} ]; then
		${2:#statements}
snippet for
	for ((${2:i} = 0; $2 < ${1:count}; $2++))
	do
		${3:#statements}
	done
snippet remove unset
	for ((i = 0; i < \${#${1:array}[@]}; i++))
	do
		[ "\${$1[i]}" ${2:condition} ] && unset $1[i]${3}
	done
snippet remove fully
	typeset -a $2Copy=()
	typeset ${1:element}
	for $1 in "\${${2:array}[@]}"
	do
		[ "\$$1" ${3:condition} ] || $2Copy+=("\$$1")
	done
	$2=("\${$2Copy[@]}"); unset $2Copy; unset $1${4}
snippet remove single element fully via index (getIndex)
	${1:array}=("\${$1[@]:0:${2:index}}" "\${$1[@]:$(($2+1))}")${3}
snippet wh
	while ${1:condition}
	do
		${2:#statements}
	done
snippet until
	until ${1:condition}
	do
		${2:#statements}
	done
snippet select skeleton
	select ${1:variable} in ${2:words}
	do
		if [ "\$$1" ]; then
			${3:#statements}
			break
		elif [ "\$REPLY" = ${4:default} ]; then
			${5:#default case}
			break
		fi
	done${6}
snippet select single entry with help
	select ${1:variable} in ${2:words}
	do
		if [ "\$$1" ]; then
			${3:#statements}
			break
		elif [ ! "\$REPLY" ]; then
			exit 1
		else
			cat >&2 <<-'EOF'
				Enter a number to select the ${4:entry}.
				Abort via Ctrl-D.
	EOF
		fi
	done${5}
snippet select single entry with drill-down
	select ${1:variable} in ${2:words}
	do
		if [ "\$$1" ]; then
			${3:#statements}
			break
		elif [ ! "\$REPLY" ]; then
			exit 1
		elif [ "\$REPLY" = '?' ]; then
			cat >&2 <<-'EOF'
				Enter a number to select the ${4:entry}.
				Filter the list by entering "grep" arguments. (Double backslashes.)
				Abort via Ctrl-D.
	EOF
		else
			typeset -a filtered$2=($(printf '%s\n' "\$$2" | grep $REPLY))
			${5:function} "${filtered$2[@]}"
			break
		fi
	done${6}
snippet select multiple entries with help
	typeset -a selected$2=()
	select ${1:variable} in ${2:words}
	do
		if [ "\$$1" ]; then
			selected$2+=("\$$1")
		elif [ "\$REPLY" = '.' ]; then
			break
		else
			cat >&2 <<-'EOF'
				Enter each number (one after the other) to select the ${3:entry}.
				Conclude by pressing Ctrl-D or entering "."
	EOF
		fi
	done${4}
snippet select multiple entries with drill-down
	typeset -a selected$2=()
	select ${1:variable} in ${2:words}
	do
		if [ "\$$1" ]; then
			selected$2+=("\$$1")
		elif [ "\$REPLY" = '.' ]; then
			break
		else
			cat >&2 <<-'EOF'
				Enter each number (one after the other) to select the ${3:entry}.
				Filter the list by entering "grep" arguments. (Double backslashes.)
				Conclude by pressing Ctrl-D or entering "."
	EOF
		else
			typeset -a filtered$2=($(printf '%s\n' "\$$2" | grep $REPLY))
			${5:function} "${filtered$2[@]}"
			break
		fi
	done${4}
snippet wait
	let attempts=1
	until ${1:condition}
	do
		${2:#statements}
		echo "${3:Not yet online} ($attempts)..."
		sleep ${4:10}
		let attempts+=1
		if [ \$attempts -gt ${5:maxAttempts} ]; then
			echo >2 "FATAL: ${6:subject} did not come up!"
			${7:return} 1
		fi
	done
	[ \$attempts -eq 1 ] && echo "$6 ready!" || echo "$6 is now ready!"
	${8}
snippet case
	case ${1:word} in
		${2:pattern})
			${3};;
	esac
snippet case-grep-values simple
	scriptFilespec="\$0"
	case ${1:word} in
		# ${2:MARKER}_BEGIN
		${3:pattern) # [-f|--foo] FILE1 [...]}
		# $2_END
		*)
			echo >&2 "ERROR: No or invalid $2. Pass one of:"
			sed -n -e '/^\s*# $2_BEGIN/,/^\s*# $2_END/s/^\s*\([^) ]*\))\s*\(#\( .*\)\|.*\)\$/\1\3/p' "\$scriptFilespec" >&2
			exit 2
			;;
	esac
snippet case-grep-values invalid vs none and separate function
	get$2s()
	{
		sed -n -e '/^\s*# $2_BEGIN/,/^\s*# $2_END/s/^\s*\([^) ]*\))\s*\(#\( .*\)\|.*\)\$/\1\3/p' "\$scriptFilespec" >&2
	}
	scriptFilespec="\$0"
	case ${1:word} in
		# ${2:MARKER}_BEGIN
		${3:pattern) # [-f|--foo] FILE1 [...]}
		# $2_END
		.*)
			echo >&2 "ERROR: Invalid $2. Pass one of:"
			get$2s
			exit 2
			;;
		*)
			echo >&2 "ERROR: No $2 passed. Pass one of:"
			get$2s
			exit 2
			;;
	esac
snippet here pipe literal
	(cat <<'${1:EOF}'
		${2}
	$1
	) | ${3:cmd}
snippet here pipe literal, leading tabs stripped
	(cat <<-'${1:EOF}'
		${2}
	$1
	) | ${3:cmd}
snippet here pipe parameter-expanded
	(cat <<${1:EOF}
		${2}
	$1
	) | ${3:cmd}
snippet here pipe parameter-expanded, leading tabs stripped
	(cat <<-${1:EOF}
		${2}
	$1
	) | ${3:cmd}
snippet here literal
	${1:cat} <<'${2:EOF}'
		${3}
	$2${4}
snippet here literal, leading tabs stripped
	${1:cat} <<-'${2:EOF}'
		${3}
	$2${4}
snippet here parameter-expanded
	${1:cat} <<${2:EOF}
		${3}
	$2${4}
snippet here parameter-expanded, leading tabs stripped
	${1:cat} <<-${2:EOF}
		${3}
	$2${4}
snippet pipe-stderr Posix
	(${1:command} 3>&1 1>&2 2>&3 | ${2:grep -v ANNOYING_ERRORS}) 3>&1 1>&2 2>&3 ${3:| grep TARGET_STRINGS}
snippet pipe-stderr Bash process substitution
	(${1:command} 2> <(${2:grep -v ANNOYING_ERRORS}) ) ${3:| grep TARGET_STRINGS}
snippet default on empty or unset
	: \${${1:variable}:=${2:default value}}${3}
snippet default on unset
	: \${${1:variable}=${2:default value}}${3}
snippet default exported on empty or unset
	: \${${1:variable}:=${2:default value}}; export $1${3}
snippet default exported on unset
	: \${${1:variable}=${2:default value}}; export $1${3}
snippet cla-rcfile
	[ -r ~/.${1:programname}rc ] && eval 'set -- "$@" ' $(cat ~/.$1rc)${2}
snippet cla-helponly
	printUsage()
	{
		cat <<HELPTEXT
	${1:Short textual description.}
	# Note: short followed by long option; if the user knows the short one, she can
	# skim the long one.
	HELPTEXT
		printf 'Usage: %q %s\n' "$(basename "\$1")" '${2:[-f|--foo bar]} ${3:[FILE, ...]} [-?|-h|--help]'
	}
	case "\$1" in
		--help|-h|-\?)	shift; printUsage "\$0"; exit 0;;
	esac

snippet cla-skeleton custom arguments
	while [ $# -ne 0 ]
	do
		case "\$1" in
			--help|-h|-\?)	shift; print`ingo#search#timelimited#IsBufferContains('printLongUsage') ? 'Long' : ''`Usage "\$0"; exit 0;;${1}
			--)		shift; break;;
			-*)		{ echo "ERROR: Unknown option \"\$1\"!"; echo; print`ingo#search#timelimited#IsBufferContains('printShortUsage') ? 'Short' : ''`Usage "\$0"; } >&2; exit 2;;
			*)		break;;
		esac
	done
	if [ $# -eq 0 ]; then
		printUsage "\$0" >&2
		exit 2
	fi
	if [ $# -ne 0 ]; then
		files="$@"
	fi
	${2}
snippet cla-skeleton eatargs
	typeset -a ${1:allargs}=()
	while [ $# -ne 0 ]
	do
		case "\$1" in
			--help|-h|-\?)	shift; print`ingo#search#timelimited#IsBufferContains('printLongUsage') ? 'Long' : ''`Usage "\$0"; exit 0;;${2}
			--)		shift; break;;
			*)		$1+=("\$1")
							shift
							;;
		esac
	done
	if [ $# -eq 0 ]; then
		printUsage "\$0"
		exit 2 >&2
	fi
	if [ $# -ne 0 ]; then
		files="$@"
	fi
	${3:echo} "\${$1[@]}"
	${4}
snippet cla-skeleton wrapperargs
	typeset -a ${1:wrapperargs}=()
	while [ $# -ne 0 ]
	do
		case "\$1" in
			-[${2:AaCfGgKVvXxYy_options}]*)	$1+=("\$1"); shift;;
			--@(${4:all|version_long_options}))	$1+=("\$1"); shift;;
			-[${3:bcDEeFIiLlmOopQRSWw_params}])	$1+=("\$1" "\$2"); shift; shift;;
			--@(${5:foo|bar_long_params}))	$1+=("\$1" "\$2"); shift; shift;;
			--help|-h|-\?)	shift; print`ingo#search#timelimited#IsBufferContains('printLongUsage') ? 'Long' : ''`Usage "\$0"; exit 0;;
			--)		$1+=("\$1"); break;;
			*)		break;;
		esac
	done
	${6:echo} "\${$1[@]}" "$@"
	${7}
snippet cla-skeleton wrapperargs that support --long-form=value
	typeset -a ${1:wrapperargs}=()
	while [ $# -ne 0 ]
	do
		case "\$1" in
			-[${2:AaCfGgKVvXxYy_options}]*)	$1+=("\$1"); shift;;
			--@(${4:all|version_long_options}))	$1+=("\$1"); shift;;
			-[${3:bcDEeFIiLlmOopQRSWw_params}])	$1+=("\$1" "\$2"); shift; shift;;
			--@($5)=*)	$1+=("\$1"); shift;;
			--@(${5:foo|bar_long_params}))	$1+=("\$1" "\$2"); shift; shift;;
			--help|-h|-\?)	shift; print`ingo#search#timelimited#IsBufferContains('printLongUsage') ? 'Long' : ''`Usage "\$0"; exit 0;;
			--)		$1+=("\$1"); break;;
			*)		break;;
		esac
	done
	${6:echo} "\${$1[@]}" "$@"
	${7}
snippet cla-option
	--${1:nofoo}${2:|-f})		shift; ${3:is}${4:$1}=t;;${5}
snippet cla-param
	--${1:foo}${2:|-f})		shift; ${3:$1}="\$1"; shift;;${4}
snippet cla-param-multi
	--${1:foo}${2:|-f})		shift; ${3:$1s}+=("\$1"); shift;;${4}
snippet cla-verification
	# Verify parsed arguments here.
snippet allargs
	typeset arg
	typeset -a allargs=()
	for arg
	do
		allargs+=("\$arg")
	done
	${1:echo} "${allargs[@]}"
snippet cla-eatargs
	typeset -a allargs=()
	*)
		allargs+=("\$1")
		shift
		;;
	${1:echo} "${allargs[@]}"
snippet cla-filterargs
	typeset -a allargs=()
	while [ $# -ne 0 ]
	do
		case "\$1" in
			--help|-h|-\?)	shift; printUsage "\$0"; exit 0;;
			--${1:filtered})	shift;;
			*)
				allargs+=("\$1")
				shift
				;;
		esac
	done
	set -- "${allargs[@]}"
	echo ${2:echo} "$@"
snippet cla-usage simple
	printUsage()
	{
		cat <<HELPTEXT
	${1:Short textual description.}
	# Note: short followed by long option; if the user knows the short one, she can
	# skim the long one.
	HELPTEXT
		printf 'Usage: %q %s\n' "$(basename "\$1")" '${2:[-f|--foo bar]} ${3:[FILE, ...]} [-?|-h|--help]'
	}
snippet cla-usage short and long
	printShortUsage()
	{
		# Note: short followed by long option; if the user knows the short one, she can
		# skim the long one.
		printf 'Usage: %q %s\n' "$(basename "\$1")" '${2:[-f|--foo bar]} ${3:[FILE, ...]} [-?|-h|--help]'
	}
	printUsage()
	{
		# This is the short help when launched with no or incorrect arguments.
		# It is printed to stderr to avoid accidental processing.
		printShortUsage "\$1" >&2
		printf >&2 'Try %q --help for more information.\n' "$(basename "\$1")"
	}
	printLongUsage()
	{
		# This is the long "man page" when launched with the help argument.
		# It is printed to stdout to allow paging with 'more'.
		cat <<HELPDESCRIPTION
	Short textual description.
	HELPDESCRIPTION
		echo
		printShortUsage "\$1"
		cat <<HELPTEXT
	# Note: long followed by short option, so that the user is able to scan through
	# the full names, then see the abbreviation.
	# Note: Order options logically as in the short helptext; sort alphabetically if
	# there are many options.
		--foo|-f	Enables foo'ing with argument bar.
	# Note: Multiline alternative if both short and long option do not fit.
	#	--foo		Enables foo'ing with argument bar.
	#	 -f			

	Example:
	HELPTEXT
		printf '%q %s\n' "$(basename "\$1")" '--foo bar /tmp/foobar'
	}
snippet cla-skip
	while [ \$# -ne 0 ]
	do
		case "\$1" in
			-[${1:AaCfGgKVvXxYy_options}]*)  shift;;
			--@(${3:all|version_long_options}))	shift;;
			-[${2:bcDEeFIiLlmOopQRSWw_params}])	    shift; shift;;
			--@(${4:foo|bar_long_params}))	shift; shift;;
			--)				    shift; break;;
			*)				    break;;
		esac
	done${4}
snippet cla-color find in arguments
	if [ ! -t 1 ] && ! contains '--color=always' "$@" || contains '--no-color' "$@" || contains '--color=never' "$@"; then
		${1:# Turn off color.}
	fi${2}
snippet cla-color find in array
	if [ ! -t 1 ] && ! contains '--color=always' "${${1:array}[@]}" || contains '--no-color' "${1[@]}" || contains '--color=never' "${1[@]}"; then
		${2:# Turn off color.}
	fi${3}
snippet cla-color parse
	colorArg=
	--color=*|--no-color)		colorArg=\$1; shift;;
	${1}
	if [ ! -t 1 ] && [ "$colorArg" != '--color=always' ] || [ "$colorArg" = '--no-color' ] || [ "$colorArg" = '--color=never' ]; then
		${2:# Turn off color.}
	fi${3}
snippet scriptDir Bash
	readonly scriptDir=$([ "${BASH_SOURCE[0]}" ] && dirname -- "${BASH_SOURCE[0]}" || exit 3)
	[ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
snippet scriptDir Bash absolute filespec
	readonly scriptDir=$([ "${BASH_SOURCE[0]}" ] && absoluteScriptFile="$(readlink -nf -- "${BASH_SOURCE[0]}")" && dirname -- "$absoluteScriptFile" || exit 3)
	[ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
snippet scriptDir Bash sourced script
	_scriptDir=$([ "${BASH_SOURCE[0]}" ] && dirname -- "${BASH_SOURCE[0]}" || exit 3)
	[ -d "$_scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; return 3; }
	${0}
	unset _scriptDir
snippet scriptDir Posix absolute filespec
	scriptDir=$(dirname -- "\$0")
	[ "$scriptDir" = "." ] && scriptDir=$(dirname -- $(which -- "\$0")) || scriptDir=$(cd "$scriptDir" && printf '%s' "$PWD") || { echo >&2 "ERROR: Cannot determine absolute script dirspec!"; exit 3; }
	[ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
	readonly scriptDir
snippet scriptName Bash
	readonly scriptName=$(basename -- "\${BASH_SOURCE[0]}")
snippet scriptName Posix
	readonly scriptName=\$(basename -- "\$0")
snippet scriptFilespec Bash
	readonly scriptFilespec="${BASH_SOURCE[0]}"
snippet scriptFilespec Posix absolute filespec
	scriptDir=$(dirname -- "\$0")
	[ "$scriptDir" = "." ] && scriptDir=$(dirname -- $(which -- "\$0")) || scriptDir=$(cd "$scriptDir" && printf '%s' "$PWD") || { echo >&2 "ERROR: Cannot determine absolute script dirspec!"; exit 3; }
	[ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
	readonly scriptFilespec="${scriptDir}/\$0"
	[ -e "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script filespec!"; exit 3; }
snippet set-unsetVariables
	set -u # Unset variables are fatal errors.
snippet set-terminateOnError
	set -e # Terminate the script at first error.
snippet tempfile with script name
	${1:TMPFILE}=$(mktemp --tmpdir "$(basename -- "\$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "\$0").$$$RANDOM")
snippet tempfile with custom name
	${1:TMPFILE}=$(mktemp --tmpdir "${2:prefix}-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$2.$$$RANDOM")${3}
snippet tempfile in custom dir
	${1:TMPFILE}=$(mktemp --tmpdir="${2:dirspec}" "${3:XXXXXX}" 2>/dev/null || echo "${TEMP:-/tmp}/$2.$$$RANDOM")${3}
snippet tempfile cleanup
	cleanup()
	{
		rm -f "${1:$TMPFILE}" 2>/dev/null
	}
	[ "$DEBUG" ] || trap 'cleanup' EXIT
snippet tempdir with script name
	${1:TMPDIR}=$(mktemp --directory --tmpdir "$(basename -- "\$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "\$0").$$$RANDOM")
snippet tempdir with custom name
	${1:TMPDIR}=$(mktemp --directory --tmpdir "${2:prefix}-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$2.$$$RANDOM")${3}
snippet tempdir cleanup
	cleanup()
	{
		rm -rf "${1:$TMPDIR}" 2>/dev/null
	}
	[ "$DEBUG" ] || trap 'cleanup' EXIT
snippet cleanup inline
	[ "$DEBUG" ] || trap '${1:cleanup-command} 2>/dev/null' EXIT
snippet cleanup with function
	cleanup()
	{
		${1:cleanup-command} 2>/dev/null
	}
	[ "$DEBUG" ] || trap 'cleanup' EXIT
snippet cleanup remaining jobs
	trap "jobs -p | xargs kill --" EXIT  # Kill remaining jobs when the script exits.
snippet cleanup any spawned subshell processes, relaunching current script as new process group leader if necessary
	pgid=$(($(ps -o pgid= -p "$$")))
	[ $$ -eq $pgid ] || exec setsid "${BASH_SOURCE[0]}" "$@" # Use setsid instead of set -m (...) to avoid having another subshell in between.
	trap "kill -- -$pgid" EXIT  # Kill subshell processes when the script exits.
snippet cleanup any spawned subshell processes, assuming direct start from interactive shell
	trap "kill -- -$$ 2>/dev/null" EXIT  # When directly launched from an interactive shell, the process becomes the process group leader, its PGID copied from its PID. Kill subshell processes when the script exits. Attention! Will leave subshell processes behind if invoked from another script.
snippet cleanup all processes within the same process group
	trap "kill 0" EXIT  # Kill processes from the same process group (includes invoking scripts!) when the script exits.
snippet finally
	finally()
	{
		${1:finally-command} 2>/dev/null
	}
	trap 'finally' EXIT
snippet filter-backup
	# Filter out backup files.
	case "$(basename -- "$${1:file}")" in
		*.[1-2][0-9][0-9][0-9][0-9][0-9][0-9][0-9][a-z])    continue;;
	esac
snippet filter-backup-glob
	!(*.[1-2][0-9][0-9][0-9][0-9][0-9][0-9][0-9][a-z])
snippet pipefail
	set -o pipefail
snippet noglob
	set -o noglob
snippet extglob
	shopt -qs extglob${1: # Enable extended file pattern matching operators from ksh (?(pattern-list), !(pattern-list), ...) in Bash.}${2}
snippet shopt-with-undo
	# Remember whether it was originally set, so we know whether to unset it.
	shopt -q ${1:option}; $1_set=\$?
	# Set if it wasn't originally set.
	(($1_set)) && shopt -s $1
	# Note: 0 (true) from shopt -q is "false" in a math context.

	${2}
	# Unset if it wasn't originally set.
	(($1_set)) && shopt -u $1${3}
snippet terminateOnError
	set -e # Terminate the script at first error.
snippet disableTerminateOnError
		case \$- in
			*e*)    set +e; local disabledTerminateOnError=t;;
		esac
		${1}
		[ "\${disabledTerminateOnError:-}" ] && set -e${2}
snippet terminateOnUnsetVar
	set -u # Unset variables are fatal errors.
snippet bash-guard
	[ "\${BASH_VERSION:-}" ] || return
snippet ksh-guard
	[ "\${KSH_VERSION:-}" ] || return
snippet nonsh-guard
	[ "${BASH_VERSION:-}" -o "${KSH_VERSION:-}" ] || return
snippet bash-versionguard
	[ \${BASH_VERSINFO[0]} -ge ${1:4} ] || { echo >&2 "ERROR: This script requires Bash $1.0 or higher!"; exit 2; }${2}
snippet bash-version above version
	[ "\${BASH_VERSINFO:-}" ] && [ \( \${BASH_VERSINFO[0]} -eq ${1:4} -a \${BASH_VERSINFO[1]} -ge ${2:0} \) -o \${BASH_VERSINFO[0]} -gt $1 ]${3}
snippet bash-version below version
	[ "\${BASH_VERSINFO:-}" ] && [ \( \${BASH_VERSINFO[0]} -eq ${1:4} -a \${BASH_VERSINFO[1]} -le ${2:0} \) -o \${BASH_VERSINFO[0]} -lt $1 ]${3}
snippet execute a single command with arguments in array
	"${${1:commandLine[@]}}"${2}
snippet execute command line(s) as separate or remaining arguments
	# -c|--command "COMMANDLINE" [-c ...] | [--] SIMPLECOMMAND [...]
	--command|-c CMD	The command line to be executed. When this is a simple
			command, it can also be passed as such.
	${1}
	isNeedEval=
	typeset -a commands=()
	while [ $# -ne 0 ]
	do
		case "\$1" in
			--command|-c)		shift; commands+=(${commands:+;} "\$1"); isNeedEval=t; shift;;
			--)		shift; break;;
			-*)		{ echo "ERROR: Unknown option \"\$1\"!"; echo; print`ingo#search#timelimited#IsBufferContains('printShortUsage') ? 'Short' : ''`Usage "\$0"; } >&2; exit 2;;
			*)		break;;
		esac
	done
	if [ $# -ne 0 ]; then
		if [ "$isNeedEval" ]; then
			# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
			# undo the effects of eval.
			commands+=(${commands:+;} $(printf '%q ' "$@"))
		else
			commands=("$@")
		fi
	fi
	if [ ${#commands[@]} -eq 0 ]; then
		echo >&2 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
		exit 2
	fi
	${2}
	if [ "$isNeedEval" ]; then
		eval "${commands[@]}"
	else
		"${commands[@]}"
	fi${3}
snippet execute command lines from stdin
	while IFS=$'\\n' read -r command
	do
		eval "$command"
	done
snippet execute array or remaining arguments as shell command-line (NOT RECOMMENDED)
	# No need for double quoting ("uname && echo \\"foo bar\\"), supports pipeline
	# and list operators if they are separate arguments; i.e. separated by
	# whitespace: uname \\&\\& echo "foo bar"
	# Does not support variables and redirection.
	commandLineEscape()
	{
		local separator=
		for arg
		do
			case "$arg" in
				\||\|\&|\&\&|\|\||\;|\(|\))   printf '%s%s' "$separator" "$arg";;
				*)			    printf '%s%q' "$separator" "$arg";;
			esac
		separator=' '
		done
	}

	eval "$(commandLineEscape "$${1:@}")"${2}
snippet shellquote all
	shellquote()
	{
	    typeset -r qq=\\'; printf %s\\\\n "'\${1//\\'/\${qq}\\\\\${qq}\${qq}}'";
	}
snippet shellquote on demand
	shellquote()
	{
		case "\$1" in
			*[\$'\\\\ \`\'\"\n\r\t\v?*[]!+']*) typeset -r qq=\\'; printf %s\\\\n "'\${1//\\'/\${qq}\\\\\${qq}\${qq}}'";;
			*)	printf %s\\\\n "\$1";;
		esac
	}
snippet quoted arguments: simplistic, with trailing space
	printf -v ${2:quoted}${1:var} '%q ' "$@"${3}
snippet quoted array: simplistic, with trailing space
	printf -v ${3:quoted}${1:var} '%q ' "${${2:ARGS}[@]}"${4}
snippet quoted arguments
	printf -v ${2:quoted}${1:var} '%q ' "$@"; $2$1=${$2$1% }${3}
snippet quoted array
	printf -v ${3:quoted}${1:var} '%q ' "${${2:ARGS}[@]}"; $3$1=${$3$1% }${4}
snippet printquoted arguments: simplistic, with trailing space
	printf ${1:>&2 }'%q ' "$@"; printf $1'\\n'${2}
snippet printquoted array: simplistic, with trailing space
	printf ${1:>&2 }'%q ' "${${2:ARGS}[@]}"; printf $1'\\n'${3}
snippet printquoted arguments: at least one argument exists
	printf ${1:>&2 }'%q' "\$1"; printf $1' %q' "${@:2}"; printf $1'\\n'${2}
snippet printquoted array: at least one argument exists
	printf ${1:>&2 }'%q' "${${2:ARGS}[0]}"; printf $1' %q' "${$2[@]:1}"; printf $1'\\n'${3}
snippet printquoted arguments: with check
	[ $# -gt 0 ] && printf ${1:>&2 }'%q' "\$1"; [ $# -gt 1 ] && printf $1' %q' "${@:2}"; printf $1'\\n'${2}
snippet printquoted array: with check
	[ ${#${2:ARGS}[@]} -gt 0 ] && printf ${1:>&2 }'%q' "${$2[0]}"; [ ${#$2[@]} -gt 1 ] && printf $1' %q' "${$2[@]:1}"; printf $1'\\n'${3}
snippet wordsplit into array
	read -r -d '' -a ${2:words} <<<"\$${1:var}"
	${3}"\${$2[@]}"${4}
snippet wordsplit with for loop
	read -r -d '' -a ${2:words} <<<"\$${1:var}"
	for ${3:word} in "\${$2[@]}"; do
		echo "\$$3"
	done${4}
snippet wordsplit with set -f in subshell
	(
		set -f
		for ${2:word} in \$${1:var}; do
			echo "$2"
		done
	)${3}
snippet debug
	case ",\${DEBUG}," in *,${1:`expand('%:t:r')`},*) ${2:debug-commands};; esac${3}
snippet profile
	case ",${PROFILING}," in *,${1:`expand('%:t:r')`},*) date +%S.%N; ${2:echo "$BASH_SOURCE[0]"};; esac${3}
snippet assert just message
	echo >&2 'ASSERT: ${1:Invalid whatever}'; exit 2${2}
snippet assert with value
	printf >&2 'ASSERT: ${1:Invalid action}: %s\n' "$${2:action}"; exit 2${3}
snippet callable Bash
	type -t ${1:name} >/dev/null${2}
snippet callable Posix
	type -P ${1:name} >/dev/null 2>&1${2}
snippet exists
	which ${1:name} > /dev/null 2>&1${2}
snippet timestamp
	${1:timestamp}=$(date +%s)${2}
snippet now
	${1:now=}$(date +%s)${2}
snippet epochToDate
	date --date "@${1:$epoch}"${2: +%F\ %T}${3}
snippet epochToReldate
	reldate --epoch "${1:$epoch}"${2}
snippet dateToEpoch
	date --date "${1:$date}" +%s${2}
snippet expire coarse (seconds)
	startEpoch=$(date +%s)
	${1:# do something}
	endEpoch=$(date +%s)
	${2:if }[ $((endEpoch - startEpoch)) -ge ${3:$EXPIRY_TIME_SECONDS} ]${4:; then}${5}
snippet expire fine (milliseconds)
	IFS=' ' read startEpoch startNanos <<<"$(date +%s\ %N)"
	${1:# do something}
	IFS=' ' read endEpoch endNanos <<<"$(date +%s\ %N)"
	startMillis=10#${startNanos:0:3}; endMillis=10#${endNanos:0:3}; diffMillis=$(((endEpoch - startEpoch) * 1000))
	${2:if }[ $((endMillis + diffMillis - startMillis)) -ge ${3:$EXPIRY_TIME_MILLISECONDS} ]${4:; then}${5}
snippet array-unique
	${1:list}=(\$(tr ' ' '\n' <<< "\${$1[@]}" | sort -u | tr '\n' ' '))${2}
snippet array-sorted
	IFS=\$'\n' ${1:list}=($(sort <<<"\${$1[*]}"))
snippet random
	$(($RANDOM % ${1:upperBoundExclusive}))
snippet random-half
	[ $(($RANDOM % 2)) -eq 0 ]
snippet map
	typeset -a $3=()
	for ${1:i} in "\${${2:source}[@]}"
	do
		${3:target}+=("\$(${4:command} "\$$1")")
	done
	${5}
snippet filter
	typeset -a $3=()
	for ${1:i} in "\${${2:source}[@]}"
	do
		${4:command} "\$$1"${5} && ${3:target}+=("\$$1")
	done
	${6}
snippet reduce
	typeset $4=${1:startValue}
	for ${2:i} in "\${${3:source}[@]}"
	do
		${4:accumulator}="\$(${5:command} "\$$4" "\$$2")"
	done
	${6}
snippet lastArg simplistic, defaulting to program name
	${1:lastArg}=\${!#}${2}
snippet lastArg with empty value if no arguments
	${1:lastArg}=; [ \$# -gt 0 ] && $1=\${!#}${2}
snippet lastArg all except last
	"\${@:1:\$((\$#-1))}"
snippet lastArg split off last
	${1:lastArg}=; [ \$# -gt 0 ] && $1=\${!#}
	typeset -a ${2:otherArgs}=("\${@:1:\$((\$#-1))}")${3}
snippet lastArg second-to-last
	${@:(-2):1}
snippet all-except-last
	"\${${1:var}[@]:1:\$((\${#$1[@]}-1))}"${2}
snippet lastElements empty when not enough
	\${${1:array}[@]: -${2:N}}${3}
snippet lastElements as many as possible when not enough
	let ${3:cnt}="\${#${1:array}[@]} > ${2:N} ? $2 : \${#$1[@]}"
	${4}\${$1[@]: -\$$3}${5}
snippet less
	less --RAW-CONTROL-CHARS
snippet pager
	"${PAGER:-less}" --RAW-CONTROL-CHARS
snippet pager unless output redirected
	typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS); [ -t 1 ] || pager=()
snippet pager conditional
	typeset -a pager=("${PAGER:-less}" --RAW-CONTROL-CHARS)${1:; [ -t 1 ] || pager=()}
	while [ $# -ne 0 ]
	do
		case "\$1" in
		--help|-h|-\?)	shift; printUsage "\$0"; exit 0;;
		--no-pager)	shift; pager=();;
		--)		shift; break;;
		esac
	done
	${2:some condition && }pager=()
	${3:more commands | }eval '${4:lastPipeCommand}' "${pager:+|}" '"${pager[@]}"'${5}
snippet pipe-conditional single pipeline with individual arguments
	typeset -a ${1:conditionPipeline}=()
	typeset -a $1=(${2:conditional pipe commands})
	${3:more commands | }eval '${4:lastPipeCommand}' "${$1:+|}" '"${$1[@]}"'${5}
snippet pipe-conditional pipeline(s) as quoted string
	${1:conditionPipeline}=
	$1='${2:conditional pipeline(s)}'
	${3:more commands | }eval '${4:lastPipeCommand}' "${$1:+|}\$$1"${5}
snippet field
	awk ${1:-F FS }'{ print \$${2:nr} }'${3}
snippet keep-status
	status=\$?
	${1:command}
	exit \$status
snippet status-union
	status=0
	${1:loop}
	do
		${2:command} || status=$?
	done
	exit $status${3}
snippet defined
	[ -n "\${${1:variable}+t}" ]${2}
snippet defined-and-empty
	[ -n "\${${1:variable}+t}" -a -z "$1" ]${2}
snippet confirm
	read -p "${1:Question}? (y/n) " choice
	${2}[ "$choice" = 'y' ]${3}
snippet confirm with timeout
	read -t ${1:seconds} -p "${2:Question}? (y/n) " choice
	${3}[ "$choice" = 'y' ]${4}
snippet query
	read -e -r -p "${2:Prompt} " ${1:var}${3}
snippet query into array
	read -e -r -p "${2:Prompt} " -a ${1:var}${3}
snippet toterm?
	[ -t 1 ]
snippet toterm
	# Force printing directly to terminal, even if stdout is redirected.
	{ exec >/dev/tty; } 2>/dev/null${1: || exit}${2}
snippet fromterm
	# Force reading directly from terminal / null device if stdin is redirected,
	# to avoid consuming input.
	{ exec 0</dev/tty; } 2>/dev/null${1: || exec </dev/null}${2}
snippet alias enable subcommands
	# Allow definition of ${2:$1} aliases putting an executable / alias "$1-foo"
	# somewhere in the PATH.
	exists ${1:command} && $1() {
		typeset -r $1Alias="$1-$1"
		if [ $# -eq 0 ]; then
			$1 ${${3:$1}_DEFAULT_COMMAND:-${4:default-arg}}
		elif type -t "$$1Alias" >/dev/null; then
			shift
			eval $$1Alias '"$@"'
		else
			command $1 "$@"
		fi
	}${5}
snippet log-redir
	exec > "/var/log/\$USER/${1:scriptName}.log"; exec 2>&1${2}
snippet file-older
	[ "$(find "${1:\$filespec}" -mmin +${2:minutes})" ]${3}
snippet file-newer
	[ "$(find "${1:\$filespec}" -mmin -${2:minutes})" ]${3}
snippet plural scalar
	${1:what}Plural=${3:s}; [ \$$1 -eq 1 ] && $1Plural=${2}${4}
snippet plural array
	${1:what}Plural=${3:s}; [ \${#$1[@]} -eq 1 ] && $1Plural=${2}${4}
snippet verb
	${1:what}Verb=${3:have}; [ \$$1 -eq 1 ] && $1Verb=${4:has}${2}${5}
snippet plural-verb
	${1:what}Plural=${3:s}; $1Verb=${4:have}; [ \$$1 -eq 1 ] && { $1Plural=; $1Verb=${5:has}; }${2}${6}
# https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
snippet xdg config home with initialization
	readonly CONFIG_DIRSPEC=${XDG_CONFIG_HOME:-~/.config}/${1:`expand('%:t:r')`}
	[ -d "$CONFIG_DIRSPEC" ] || mkdir -p -- "$CONFIG_DIRSPEC" || { printf >&2 'ERROR: Could not initialize configuration store at %s!\n' "$CONFIG_DIRSPEC"; exit 3; }${2}
snippet xdg user specific configuration files
	${XDG_CONFIG_HOME:-~/.config}
snippet xdg preference-ordered :-separated set of base directories to search for configuration files in addition to the $XDG_CONFIG_HOME base directory
	${XDG_CONFIG_DIRS:-/etc/xdg}
snippet xdg data home with initialization
	readonly DATA_DIRSPEC=${XDG_DATA_HOME:-~/.local/share}/${1:`expand('%:t:r')`}
	[ -d "$DATA_DIRSPEC" ] || mkdir -p -- "$DATA_DIRSPEC" || { printf >&2 'ERROR: Could not initialize data store at %s!\n' "$DATA_DIRSPEC"; exit 3; }${2}
snippet xdg user specific data files
	${XDG_DATA_HOME:-~/.local/share}
snippet xdg preference-ordered :-separated set of base directories to search for data files in addition to the $XDG_DATA_HOME base directory
	${XDG_DATA_DIRS:-/usr/local/share/:/usr/share/}
snippet xdg cache home with initialization
	readonly CACHE_DIRSPEC=${XDG_CACHE_HOME:-~/.cache}/${1:`expand('%:t:r')`}
	[ -d "$CACHE_DIRSPEC" ] || mkdir -p -- "$CACHE_DIRSPEC" || { printf >&2 'ERROR: Could not initialize cache store at %s!\n' "$CACHE_DIRSPEC"; exit 3; }${2}
snippet xdg user specific non-essential data files
	${XDG_CACHE_HOME:-~/.cache}
snippet xdg runtime home with initialization
	readonly RUNTIME_DIRSPEC=${XDG_RUNTIME_DIR:?}/${1:`expand('%:t:r')`}
	[ -d "$RUNTIME_DIRSPEC" ] || mkdir -p -- "$RUNTIME_DIRSPEC" || { printf >&2 'ERROR: Could not initialize runtime store at %s!\n' "$RUNTIME_DIRSPEC"; exit 3; }${2}
snippet xdg base directory relative to which user-specific non-essential runtime files and other file objects (such as sockets, named pipes, ...) should be stored. The directory MUST be owned by the user, and he MUST be the only one having read and write access to it
	${XDG_RUNTIME_DIR:?}
snippet read single value from file
	${1:name}Filespec="${2:filespec}"; $1=; [ -r "$$1Filespec" ] && < "$$1Filespec" IFS=$' ' read -r $1${3}
